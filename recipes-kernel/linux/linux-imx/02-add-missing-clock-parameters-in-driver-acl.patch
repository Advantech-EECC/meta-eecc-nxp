diff --git a/drivers/clk/imx/clk-imx8ulp.c b/drivers/clk/imx/clk-imx8ulp.c
index b97c4758d836..154b4cd582bf 100644
--- a/drivers/clk/imx/clk-imx8ulp.c
+++ b/drivers/clk/imx/clk-imx8ulp.c
@@ -17,6 +17,20 @@
 static const char * const pll_pre_sels[] = { "sosc", "frosc", };
 static const char * const a35_sels[] = { "frosc", "spll2", "sosc", "lvds", };
 static const char * const nic_sels[] = { "frosc", "spll3_pfd0", "sosc", "lvds", };
+static const char * const dsp_sels[] = { "frosc", "pll0_pfd0", "pll0_pfd1", "sosc", "dummy", "dummy", "pll0", "dummy", };
+static const char * const cm33_sels[] = { "frosc", "pll0_pfd0", "pll1_pfd0", "sosc", "dummy", "dummy", "pll0", "dummy", };
+
+/* Add PCC0/PCC2 from RM Table 35. Clock sources mapped to different PCC0/1/2 clock selects PCS */
+static const char * const pcc0_periph_bus_sels[] = { "dummy", "lposc", "cgc0_sosc_div2",
+						     "cgc0_frosc_div2", "cm33_busclk", "pll1_pfd1_div",
+						     "pll0_pfd2_div", "pll0_pfd1_div", };
+static const char * const pcc0_periph_plat_sels[] = { "dummy", "dummy", "dummy",
+						     "cgc0_sosc_div1", "cgc0_frosc_div1", "cm33_plat",
+						     "frosc", "pll0_pfd3", };
+static const char * const pcc2_periph_bus_sels[] = { "dummy", "lposc", "cgc0_sosc_div3",
+						     "cgc0_frosc_div3", "cgc0_dsp_bus_clk", "pll1_vcodiv",
+						     "pll0_pfd2_div", "pll0_pfd1_div", };
+
 static const char * const pcc3_periph_bus_sels[] = { "dummy", "lposc", "sosc_div2",
 						     "frosc_div2", "xbar_divbus", "spll3_pfd1_div1",
 						     "spll3_pfd0_div2", "spll3_pfd0_div1", };
@@ -41,6 +55,7 @@ static const char * const ddr_sels[] = { "frosc", "pll4_pfd1", "sosc", "lvds",
 static const char * const lpav_sels[] = { "frosc", "pll4_pfd1", "sosc", "lvds", };
 static const char * const sai45_sels[] = { "spll3_pfd1_div1", "aud_clk1", "aud_clk2", "sosc", };
 static const char * const sai67_sels[] = { "spll1_pfd2_div", "spll3_pfd1_div1", "aud_clk0", "aud_clk1", "aud_clk2", "sosc", "dummy", "dummy", };
+static const char * const tpm67_sels[] = { "spll3_pfd1_div1", "aud_clk1", "aud_clk2", "sosc_tpm", };
 static const char * const aud_clk1_sels[] = { "ext_aud_mclk2", "sai4_rx_bclk", "sai4_tx_bclk", "sai5_rx_bclk", "sai5_tx_bclk", "dummy", "dummy", "dummy", };
 static const char * const aud_clk2_sels[] = { "ext_aud_mclk3", "sai6_rx_bclk", "sai6_tx_bclk", "sai7_rx_bclk", "sai7_tx_bclk", "spdif_rx", "dummy", "dummy", };
 static const char * const enet_ts_sels[] = { "ext_rmii_clk", "ext_ts_clk", "rosc", "ext_aud_mclk", "sosc", "dummy", "dummy", "dummy"};
@@ -60,6 +75,15 @@ struct pcc_reset_dev {
 #define PCC_SW_RST	BIT(28)
 #define to_pcc_reset_dev(_rcdev)	container_of(_rcdev, struct pcc_reset_dev, rcdev)
 
+static const u32 pcc0_resets[] = {
+};
+
+static const u32 pcc1_resets[] = {
+};
+
+static const u32 pcc2_resets[] = {
+};
+
 static const u32 pcc3_resets[] = {
 	0xa8, 0xac, 0xc8, 0xcc, 0xd0,
 	0xd4, 0xd8, 0xdc, 0xe0, 0xe4,
@@ -142,6 +166,81 @@ static int imx8ulp_pcc_reset_init(struct platform_device *pdev, void __iomem *ba
 	return devm_reset_controller_register(dev, &pcc_reset->rcdev);
 }
 
+static int imx8ulp_clk_cgc0_init(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct clk_hw_onecell_data *clk_data;
+	struct clk_hw **clks;
+	void __iomem *base;
+
+	clk_data = devm_kzalloc(dev, struct_size(clk_data, hws, IMX8ULP_CLK_CGC0_END),
+			   GFP_KERNEL);
+	if (!clk_data)
+		return -ENOMEM;
+
+	clk_data->num = IMX8ULP_CLK_CGC0_END;
+	clks = clk_data->hws;
+
+	/* CGC0 */
+	base = devm_platform_ioremap_resource(pdev, 0);
+	if (WARN_ON(IS_ERR(base)))
+		return PTR_ERR(base);
+
+	clks[IMX8ULP_CLK_PLL1_PRE_SEL]	= imx_clk_hw_mux_flags("pll1_pre_sel", base + 0x610, 0, 1, pll_pre_sels, ARRAY_SIZE(pll_pre_sels), CLK_SET_PARENT_GATE);
+	clks[IMX8ULP_CLK_PLL0_PRE_SEL]	= imx_clk_hw_mux_flags("pll0_pre_sel", base + 0x510, 0, 1, pll_pre_sels, ARRAY_SIZE(pll_pre_sels), CLK_SET_PARENT_GATE);
+	clks[IMX8ULP_CLK_CGC0_DSP_SEL] = imx_clk_hw_mux_flags("cgc0_dsp_sel", base + 0x1c, 28, 3, dsp_sels, ARRAY_SIZE(dsp_sels), CLK_SET_PARENT_GATE);
+
+	clks[IMX8ULP_CLK_CM33_SEL] = imx_clk_hw_mux_flags("cm33_sel", base + 0x10, 28, 3, cm33_sels, ARRAY_SIZE(cm33_sels), CLK_SET_PARENT_GATE);
+
+	clks[IMX8ULP_CLK_PLL1] = imx_clk_hw_pllv4(IMX_PLLV4_IMX8ULP, "pll1", "pll1_pre_sel", base + 0x600);
+	clks[IMX8ULP_CLK_PLL0] = imx_clk_hw_pllv4(IMX_PLLV4_IMX8ULP, "pll0", "pll0_pre_sel", base + 0x500);
+
+	clks[IMX8ULP_CLK_PLL0_VCODIV] = imx_clk_hw_divider("pll0_vcodiv", "pll0", base + 0x504, 0, 6);
+	clks[IMX8ULP_CLK_PLL1_VCODIV] = imx_clk_hw_divider("pll1_vcodiv", "pll1", base + 0x604, 0, 6);
+
+	clks[IMX8ULP_CLK_PLL0_PFD0] = imx_clk_hw_pfdv2(IMX_PFDV2_IMX8ULP, "pll0_pfd0", "pll0_vcodiv", base + 0x514, 0);
+	clks[IMX8ULP_CLK_PLL0_PFD1] = imx_clk_hw_pfdv2(IMX_PFDV2_IMX8ULP, "pll0_pfd1", "pll0_vcodiv", base + 0x514, 1);
+	clks[IMX8ULP_CLK_PLL0_PFD2] = imx_clk_hw_pfdv2(IMX_PFDV2_IMX8ULP, "pll0_pfd2", "pll0_vcodiv", base + 0x514, 2);
+	clks[IMX8ULP_CLK_PLL0_PFD3] = imx_clk_hw_pfdv2(IMX_PFDV2_IMX8ULP, "pll0_pfd3", "pll0_vcodiv", base + 0x514, 3);
+
+	clks[IMX8ULP_CLK_PLL1_PFD1] = imx_clk_hw_pfdv2(IMX_PFDV2_IMX8ULP, "pll1_pfd1", "pll1_vcodiv", base + 0x614, 1);
+
+	clks[IMX8ULP_CLK_CGC0_SOSC_DIV1_GATE] = imx_clk_hw_gate_dis("cgc0_sosc_div1_gate", "sosc", base + 0x108, 7);
+	clks[IMX8ULP_CLK_CGC0_SOSC_DIV1] = imx_clk_hw_divider("cgc0_sosc_div1", "cgc0_sosc_div1_gate", base + 0x108, 0, 6);
+	clks[IMX8ULP_CLK_CGC0_SOSC_DIV2_GATE] = imx_clk_hw_gate_dis("cgc0_sosc_div2_gate", "sosc", base + 0x108, 15);
+	clks[IMX8ULP_CLK_CGC0_SOSC_DIV2] = imx_clk_hw_divider("cgc0_sosc_div2", "cgc0_sosc_div2_gate", base + 0x108, 8, 6);
+	clks[IMX8ULP_CLK_CGC0_SOSC_DIV3_GATE] = imx_clk_hw_gate_dis("cgc0_sosc_div3_gate", "sosc", base + 0x108, 23);
+	clks[IMX8ULP_CLK_CGC0_SOSC_DIV3] = imx_clk_hw_divider("cgc0_sosc_div3", "cgc0_sosc_div3_gate", base + 0x108, 16, 6);
+
+	clks[IMX8ULP_CLK_CGC0_FROSC_DIV1_GATE] = imx_clk_hw_gate_dis("cgc0_frosc_div1_gate", "frosc", base + 0x220, 7);
+	clks[IMX8ULP_CLK_CGC0_FROSC_DIV1] = imx_clk_hw_divider("cgc0_frosc_div1", "cgc0_frosc_div1_gate", base + 0x220, 0, 6);
+	clks[IMX8ULP_CLK_CGC0_FROSC_DIV2_GATE] = imx_clk_hw_gate_dis("cgc0_frosc_div2_gate", "frosc", base + 0x220, 15);
+	clks[IMX8ULP_CLK_CGC0_FROSC_DIV2] = imx_clk_hw_divider("cgc0_frosc_div2", "cgc0_frosc_div2_gate", base + 0x220, 8, 6);
+	clks[IMX8ULP_CLK_CGC0_FROSC_DIV3_GATE] = imx_clk_hw_gate_dis("cgc0_frosc_div3_gate", "frosc", base + 0x220, 23);
+	clks[IMX8ULP_CLK_CGC0_FROSC_DIV3] = imx_clk_hw_divider("cgc0_frosc_div3", "cgc0_frosc_div3_gate", base + 0x220, 16, 6);
+
+	clks[IMX8ULP_CLK_CGC0_DSP_CORE_DIV] = imx_clk_hw_divider("cgc0_dsp_core_div", "cgc0_dsp_sel", base + 0x1c, 21, 6);
+	clks[IMX8ULP_CLK_CGC0_DSP_BUS] = imx_clk_hw_divider("cgc0_dsp_bus_clk", "cgc0_dsp_core_div", base + 0x1c, 7, 6);
+
+	clks[IMX8ULP_CLK_PLL0_PFD1_DIV_GATE] = imx_clk_hw_gate_dis("pll0_pfd1_div_gate", "pll0_pfd1", base + 0x508, 7);
+	clks[IMX8ULP_CLK_PLL0_PFD1_DIV] = imx_clk_hw_divider("pll0_pfd1_div", "pll0_pfd1_div_gate", base + 0x508, 0, 6);
+
+	clks[IMX8ULP_CLK_PLL0_PFD2_DIV_GATE] = imx_clk_hw_gate_dis("pll0_pfd2_div_gate", "pll0_pfd2", base + 0x508, 15);
+	clks[IMX8ULP_CLK_PLL0_PFD2_DIV] = imx_clk_hw_divider("pll0_pfd2_div", "pll0_pfd2_div_gate", base + 0x508, 8, 6);
+
+	clks[IMX8ULP_CLK_PLL1_PFD1_DIV_GATE] = imx_clk_hw_gate_dis("pll1_pfd1_div_gate", "pll1_pfd1", base + 0x608, 7);
+	clks[IMX8ULP_CLK_PLL1_PFD1_DIV] = imx_clk_hw_divider("pll1_pfd1_div", "pll1_pfd1_div_gate", base + 0x608, 0, 6);
+
+	clks[IMX8ULP_CLK_CM33_CORE_DIV] = imx_clk_hw_divider("cm33_core_div", "cm33_sel", base + 0x1c, 21, 6);
+	clks[IMX8ULP_CLK_CM33_BUSCLK] = imx_clk_hw_divider("cm33_busclk", "cm33_core_div", base + 0x10, 7, 6);
+
+	imx_check_clk_hws(clks, clk_data->num);
+
+	printk("CGC0 init exit\n");
+
+	return devm_of_clk_add_hw_provider(dev, of_clk_hw_onecell_get, clk_data);
+}
+
 static int imx8ulp_clk_cgc1_init(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
@@ -158,6 +257,7 @@ static int imx8ulp_clk_cgc1_init(struct platform_device *pdev)
 	clks = clk_data->hws;
 
 	clks[IMX8ULP_CLK_DUMMY] = imx_clk_hw_fixed("dummy", 0);
+	clks[IMX8ULP_CLK_SOSC_TPM] =  imx_clk_hw_fixed("sosc_tpm", 24000000);
 
 	/* CGC1 */
 	base = devm_platform_ioremap_resource(pdev, 0);
@@ -219,6 +319,7 @@ static int imx8ulp_clk_cgc1_init(struct platform_device *pdev)
 	clks[IMX8ULP_CLK_AUD_CLK1] = imx_clk_hw_mux2("aud_clk1", base + 0x900, 0, 3, aud_clk1_sels, ARRAY_SIZE(aud_clk1_sels));
 	clks[IMX8ULP_CLK_SAI4_SEL] = imx_clk_hw_mux2("sai4_sel", base + 0x904, 0, 2, sai45_sels, ARRAY_SIZE(sai45_sels));
 	clks[IMX8ULP_CLK_SAI5_SEL] = imx_clk_hw_mux2("sai5_sel", base + 0x904, 8, 2, sai45_sels, ARRAY_SIZE(sai45_sels));
+	clks[IMX8ULP_CLK_TPM7_SEL] = imx_clk_hw_mux2("tpm7_sel", base + 0x908, 8, 2, tpm67_sels, ARRAY_SIZE(tpm67_sels));
 	clks[IMX8ULP_CLK_ENET_TS_SEL] = imx_clk_hw_mux2("enet_ts", base + 0x700, 24, 3, enet_ts_sels, ARRAY_SIZE(enet_ts_sels));
 
 	imx_check_clk_hws(clks, clk_data->num);
@@ -308,6 +409,117 @@ static int imx8ulp_clk_cgc2_init(struct platform_device *pdev)
 	return devm_of_clk_add_hw_provider(dev, of_clk_hw_onecell_get, clk_data);
 }
 
+static int imx8ulp_clk_pcc0_init(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct clk_hw_onecell_data *clk_data;
+	struct clk_hw **clks;
+	void __iomem *base;
+	int ret;
+
+	clk_data = devm_kzalloc(dev, struct_size(clk_data, hws, IMX8ULP_CLK_PCC0_END),
+			   GFP_KERNEL);
+	if (!clk_data)
+		return -ENOMEM;
+
+	clk_data->num = IMX8ULP_CLK_PCC0_END;
+	clks = clk_data->hws;
+
+	/* PCC0 */
+	base = devm_platform_ioremap_resource(pdev, 0);
+	if (WARN_ON(IS_ERR(base)))
+		return PTR_ERR(base);
+
+	// Table 31. Synchronous Clocks used by each Platform and Peripherals: Real Time Domain
+	// Do-Nothing
+
+	imx_check_clk_hws(clks, clk_data->num);
+
+	ret = devm_of_clk_add_hw_provider(dev, of_clk_hw_onecell_get, clk_data);
+	if (ret)
+		return ret;
+
+	printk("PCC0 init exit\n");
+	/* register the pcc0 reset controller */
+	return imx8ulp_pcc_reset_init(pdev, base, pcc0_resets, ARRAY_SIZE(pcc0_resets));
+}
+
+static int imx8ulp_clk_pcc1_init(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct clk_hw_onecell_data *clk_data;
+	struct clk_hw **clks;
+	void __iomem *base;
+	int ret;
+
+	clk_data = devm_kzalloc(dev, struct_size(clk_data, hws, IMX8ULP_CLK_PCC1_END),
+			   GFP_KERNEL);
+	if (!clk_data)
+		return -ENOMEM;
+
+	clk_data->num = IMX8ULP_CLK_PCC1_END;
+	clks = clk_data->hws;
+
+	/* PCC1 */
+	base = devm_platform_ioremap_resource(pdev, 0);
+	if (WARN_ON(IS_ERR(base)))
+		return PTR_ERR(base);
+
+	/* Figure 26. RGPIO clocking */
+	clks[IMX8ULP_CLK_RGPIOA] = imx_clk_hw_gate("rgpioa", "cm33_core_div", base + 0xb4, 30);
+	clks[IMX8ULP_CLK_RGPIOB] = imx_clk_hw_gate("rgpiob", "cm33_core_div", base + 0xb8, 30);
+	clks[IMX8ULP_CLK_RGPIOC] = imx_clk_hw_gate("rgpioc", "cm33_core_div", base + 0xbc, 30);
+
+	/* Figure 36. Digital filter clocking */
+	clks[IMX8ULP_CLK_PCTLA] = imx_clk_hw_gate("pctla", "cm33_core_div", base + 0x78, 30);
+	clks[IMX8ULP_CLK_PCTLB] = imx_clk_hw_gate("pctlb", "cm33_core_div", base + 0x7c, 30);
+
+	imx_check_clk_hws(clks, clk_data->num);
+
+	ret = devm_of_clk_add_hw_provider(dev, of_clk_hw_onecell_get, clk_data);
+	if (ret)
+		return ret;
+
+	printk("PCC1 init exit\n");
+	/* register the pcc1 reset controller */
+	return imx8ulp_pcc_reset_init(pdev, base, pcc1_resets, ARRAY_SIZE(pcc1_resets));
+}
+
+static int imx8ulp_clk_pcc2_init(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct clk_hw_onecell_data *clk_data;
+	struct clk_hw **clks;
+	void __iomem *base;
+	int ret;
+
+	clk_data = devm_kzalloc(dev, struct_size(clk_data, hws, IMX8ULP_CLK_PCC2_END),
+			   GFP_KERNEL);
+	if (!clk_data)
+		return -ENOMEM;
+
+	clk_data->num = IMX8ULP_CLK_PCC2_END;
+	clks = clk_data->hws;
+
+	/* PCC2 */
+	base = devm_platform_ioremap_resource(pdev, 0);
+	if (WARN_ON(IS_ERR(base)))
+		return PTR_ERR(base);
+
+	// Synchronous Clocks used by each Platform and Peripherals: Real Time Domain
+	// Do-Nothing
+
+	imx_check_clk_hws(clks, clk_data->num);
+
+	ret = devm_of_clk_add_hw_provider(dev, of_clk_hw_onecell_get, clk_data);
+	if (ret)
+		return ret;
+
+	printk("PCC2 init exit\n");
+	/* register the pcc2 reset controller */
+	return imx8ulp_pcc_reset_init(pdev, base, pcc2_resets, ARRAY_SIZE(pcc2_resets));
+}
+
 static int imx8ulp_clk_pcc3_init(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
@@ -546,9 +758,13 @@ static int imx8ulp_clk_probe(struct platform_device *pdev)
 }
 
 static const struct of_device_id imx8ulp_clk_dt_ids[] = {
+	{ .compatible = "fsl,imx8ulp-pcc0", .data = imx8ulp_clk_pcc0_init },
+	{ .compatible = "fsl,imx8ulp-pcc1", .data = imx8ulp_clk_pcc1_init },
+	{ .compatible = "fsl,imx8ulp-pcc2", .data = imx8ulp_clk_pcc2_init },
 	{ .compatible = "fsl,imx8ulp-pcc3", .data = imx8ulp_clk_pcc3_init },
 	{ .compatible = "fsl,imx8ulp-pcc4", .data = imx8ulp_clk_pcc4_init },
 	{ .compatible = "fsl,imx8ulp-pcc5", .data = imx8ulp_clk_pcc5_init },
+	{ .compatible = "fsl,imx8ulp-cgc0", .data = imx8ulp_clk_cgc0_init },
 	{ .compatible = "fsl,imx8ulp-cgc2", .data = imx8ulp_clk_cgc2_init },
 	{ .compatible = "fsl,imx8ulp-cgc1", .data = imx8ulp_clk_cgc1_init },
 	{ /* sentinel */ },
diff --git a/include/dt-bindings/clock/imx8ulp-clock.h b/include/dt-bindings/clock/imx8ulp-clock.h
index cb449c991643..ae5970967303 100644
--- a/include/dt-bindings/clock/imx8ulp-clock.h
+++ b/include/dt-bindings/clock/imx8ulp-clock.h
@@ -64,8 +64,52 @@
 #define IMX8ULP_CLK_AUD_CLK1			53
 #define IMX8ULP_CLK_ARM				54
 #define IMX8ULP_CLK_ENET_TS_SEL			55
+#define IMX8ULP_CLK_TPM7_SEL			56
+#define IMX8ULP_CLK_SOSC_TPM			57
 
-#define IMX8ULP_CLK_CGC1_END			56
+#define IMX8ULP_CLK_CGC1_END			58
+
+/* CGC0 */
+#define IMX8ULP_CLK_CM33_SEL                1
+#define IMX8ULP_CLK_PLL0_PRE_SEL            2
+#define IMX8ULP_CLK_PLL0                    3
+#define IMX8ULP_CLK_PLL0_VCODIV             4
+#define IMX8ULP_CLK_PLL0_PFD0               5
+#define IMX8ULP_CLK_PLL0_PFD1               6
+#define IMX8ULP_CLK_PLL0_PFD2               7
+#define IMX8ULP_CLK_PLL0_PFD3               8
+#define IMX8ULP_CLK_PLL1_PRE_SEL            9
+#define IMX8ULP_CLK_PLL1                    10
+#define IMX8ULP_CLK_PLL1_PFD0               11
+#define IMX8ULP_CLK_PLL1_PFD1               12
+#define IMX8ULP_CLK_PLL1_PFD2               13
+#define IMX8ULP_CLK_PLL1_PFD3               14
+#define IMX8ULP_CLK_CGC0_SOSC_DIV1          15
+#define IMX8ULP_CLK_CGC0_SOSC_DIV1_GATE     16
+#define IMX8ULP_CLK_CGC0_SOSC_DIV2          17
+#define IMX8ULP_CLK_CGC0_SOSC_DIV2_GATE     18
+#define IMX8ULP_CLK_CGC0_SOSC_DIV3          19
+#define IMX8ULP_CLK_CGC0_SOSC_DIV3_GATE     20
+#define IMX8ULP_CLK_CGC0_FROSC_DIV1         21
+#define IMX8ULP_CLK_CGC0_FROSC_DIV1_GATE    22
+#define IMX8ULP_CLK_CGC0_FROSC_DIV2         23
+#define IMX8ULP_CLK_CGC0_FROSC_DIV2_GATE    24
+#define IMX8ULP_CLK_CGC0_FROSC_DIV3         25
+#define IMX8ULP_CLK_CGC0_FROSC_DIV3_GATE    26
+#define IMX8ULP_CLK_CGC0_DSP_SEL            27
+#define IMX8ULP_CLK_CGC0_DSP_CORE_DIV       28
+#define IMX8ULP_CLK_CGC0_DSP_BUS            29
+#define IMX8ULP_CLK_PLL1_VCODIV             30
+#define IMX8ULP_CLK_PLL0_PFD1_DIV           31
+#define IMX8ULP_CLK_PLL0_PFD1_DIV_GATE      32
+#define IMX8ULP_CLK_PLL0_PFD2_DIV           33
+#define IMX8ULP_CLK_PLL0_PFD2_DIV_GATE      34
+#define IMX8ULP_CLK_PLL1_PFD1_DIV           35
+#define IMX8ULP_CLK_PLL1_PFD1_DIV_GATE      36
+#define IMX8ULP_CLK_CM33_CORE_DIV           37
+#define IMX8ULP_CLK_CM33_BUSCLK             38
+
+#define IMX8ULP_CLK_CGC0_END			    39
 
 /* CGC2 */
 #define IMX8ULP_CLK_PLL4_PRE_SEL	0
@@ -120,6 +164,20 @@
 
 #define IMX8ULP_CLK_CGC2_END		49
 
+/* PCC0 */
+#define IMX8ULP_CLK_PCC0_END		0
+
+/* PCC1 */
+#define IMX8ULP_CLK_RGPIOA          0
+#define IMX8ULP_CLK_RGPIOB          1
+#define IMX8ULP_CLK_RGPIOC          2
+#define IMX8ULP_CLK_PCTLA           3
+#define IMX8ULP_CLK_PCTLB           4
+#define IMX8ULP_CLK_PCC1_END		5
+
+/* PCC2 */
+#define IMX8ULP_CLK_PCC2_END		0
+
 /* PCC3 */
 #define IMX8ULP_CLK_WDOG3		0
 #define IMX8ULP_CLK_WDOG4		1
